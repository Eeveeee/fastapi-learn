


from contextlib import asynccontextmanager

# FastAPI is the web framework
from fastapi import Depends, FastAPI

# SQLAlchemy imports for querying the database
from sqlalchemy import select
from sqlalchemy.ext.asyncio import AsyncSession

# Local imports:
# - engine: manages DB connection pool (TCP connections)
# - Base: holds metadata for all ORM models (tables)
# - get_db: FastAPI dependency that gives us a DB session per request
from .db import Base, engine, get_db

# ORM model (represents the "users" table)
from .models import User

# Pydantic schemas (request / response validation)
from .schemas import UserCreate, UserOut


# ---------------------------------------------------------------------
# APPLICATION LIFESPAN (startup + shutdown)
# ---------------------------------------------------------------------
# This function controls what happens:
#   - once when the application STARTS
#   - once when the application STOPS
#
# It does NOT run per request.
#
# Think of this as:
#   "global app initialization and cleanup"
#
@asynccontextmanager
async def lifespan(app: FastAPI):
    """
    Lifespan context for the FastAPI application.

    Everything BEFORE `yield`:
        → runs once on application startup

    Everything AFTER `yield`:
        → runs once on application shutdown
    """

    # -------------------------
    # STARTUP PHASE
    # -------------------------
    # Here we initialize application-wide resources.
    #
    # `engine`:
    #   - owns a POOL of TCP connections to PostgreSQL
    #   - TCP connections are expensive to open
    #   - the pool keeps them open and reuses them
    #
    # `engine.begin()`:
    #   - temporarily BORROWS one TCP connection from the pool
    #   - opens a database transaction on it
    #
    async with engine.begin() as conn:
        # `run_sync` allows running blocking (sync) code safely
        # inside an async environment.
        #
        # `Base.metadata.create_all`:
        #   - creates tables if they do not exist
        #   - this is OK for learning / development
        #   - in real projects, use Alembic migrations instead
        await conn.run_sync(Base.metadata.create_all)

    # At this point:
    # - tables exist
    # - TCP connection used above is RETURNED to the pool
    # - application is ready to accept HTTP requests

    # This `yield` hands control back to FastAPI.
    # The app now starts serving requests.
    yield

    # -------------------------
    # SHUTDOWN PHASE
    # -------------------------
    # This runs once when the app is stopping (Ctrl+C, container stop, etc.)
    #
    # `engine.dispose()`:
    #   - closes ALL TCP connections in the pool
    #   - tells PostgreSQL "we are done"
    #
    # This is important for clean shutdown.
    await engine.dispose()


# ---------------------------------------------------------------------
# FASTAPI APPLICATION INSTANCE
# ---------------------------------------------------------------------
# We pass the lifespan function to FastAPI.
# FastAPI will call it automatically.
#
app = FastAPI(lifespan=lifespan)


# ---------------------------------------------------------------------
# ROUTES / ENDPOINTS
# ---------------------------------------------------------------------

@app.get("/users", response_model=list[UserOut])
async def list_users(db: AsyncSession = Depends(get_db)):
    """
    GET /users

    Important concepts here:

    - `db` is an AsyncSession (NOT a TCP connection!)
    - The session BORROWS a TCP connection from the pool
      ONLY when it needs to execute SQL.
    - After the request finishes, the connection is returned to the pool.
    """

    # Build a SQL query: SELECT * FROM users;
    stmt = select(User)

    # Execute the query using a pooled TCP connection
    result = await db.execute(stmt)

    # Extract ORM objects from the result
    users = result.scalars().all()

    return list(users)


@app.post("/users", response_model=UserOut)
async def create_user(payload: UserCreate, db: AsyncSession = Depends(get_db)):
    """
    POST /users

    Flow:
    1. Receive JSON from client
    2. Validate it with Pydantic (UserCreate)
    3. Create ORM object
    4. Commit transaction
    """

    # Convert validated input into ORM object
    user = User(**payload.model_dump())

    # Stage object for INSERT
    db.add(user)

    # Commit:
    # - opens a DB transaction
    # - uses a TCP connection from the pool
    # - writes data to PostgreSQL
    await db.commit()

    # Refresh:
    # - reloads data from DB
    # - needed to get autogenerated fields (e.g. id)
    await db.refresh(user)

    return user
